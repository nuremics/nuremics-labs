import os
import attrs
import json
import pandas as pd
from pathlib import Path

from nuremics import Process
from labs.ops.general.projectile_model import units


@attrs.define
class ProjectileModelProc(Process):
    """
    Simulate a projectile trajectory and compare it with the analytical solution.

    Pipeline
    --------
        1. operation1
            Run the physical simulation of a projectile.
        2. operation2
            Compute the theoretical trajectory using analytical equations.
        3. operation3
            Plot and save the comparison between simulated (model) and theoretical trajectories.

    Input parameters
    ----------------
        gravity : float
            Acceleration due to gravity (can be positive or negative).
        mass : float
            Mass of the projectile (used in the simulation).

    Input paths
    -----------
        velocity_file : json
            File containing initial conditions (v0, h0, angle).
        configs_folder : folder
            'solver_config.json' : File containing the parameters for solver configuration.
            'display_config.json' : File containing the parameters for display configuration.
        coords_file : csv
            File with 2D coordinates ('X', 'Y') of the polygonal shape to simulate.

    Internal variables
    ------------------
        variable1 : dict
            Initial conditions loaded from path1.
        variable2 : dict
            Solver configuration loaded from path2.
        variable3 : dict
            Display configuration loaded from path2.
        variable4 : pd.DataFrame
            DataFrame with simulated trajectory generated by the model.
        variable5 : pd.DataFrame
            DataFrame with analytical and simulated (model) trajectories.

    Outputs (stored in self.output_paths)
    -------
        comp_folder : folder
            'results.xlsx' : File containing simulated (model) and theoritical trajectories.
            'model_vs_theory.png' : Image comparing both trajectories.
    """

    # Parameters
    gravity: float = attrs.field(init=False, metadata={"input": True})
    mass: float = attrs.field(init=False, metadata={"input": True})
    
    # Paths
    velocity_file: Path = attrs.field(init=False, metadata={"input": True}, converter=Path)
    configs_folder: Path = attrs.field(init=False, metadata={"input": True}, converter=Path)
    coords_file: Path = attrs.field(init=False, metadata={"input": True}, converter=Path)

    # Internal
    variable1: dict = attrs.field(init=False)
    variable2: dict = attrs.field(init=False)
    variable3: dict = attrs.field(init=False)
    variable4: pd.DataFrame = attrs.field(init=False)
    variable5: pd.DataFrame = attrs.field(init=False)

    def __call__(self):
        super().__call__()

        self.simulate_projectile_motion()
        self.calculate_analytical_trajectory()
        self.compare_model_vs_analytical_trajectories()
    
    def simulate_projectile_motion(self):
        """
        Run the physical simulation of a projectile.

        Uses
        ----
            param1
            param2
            path1
            path2/solver_config.json
            path2/display_config.json
            path3
            variable1
            variable2
            variable3
        
        Modifies
        --------
            variable1
            variable2
            variable3
            variable4
        """

        # Load initial conditions
        with open(self.velocity_file) as f:
            self.variable1 = json.load(f)

        # Load solver configuration
        path = self.configs_folder / "solver_config.json"
        with open(path) as f:
            self.variable2 = json.load(f)

        # Load display configuration
        path = self.configs_folder / "display_config.json"
        with open(path) as f:
            self.variable3 = json.load(f)

        # Read 2D polygon shape coordinates (X, Y) from CSV file
        df_points = pd.read_csv(
            filepath_or_buffer=self.coords_file,
        )

        # Run simulation model
        trajectory = units.run_model(
            df_points=df_points,
            mass=self.mass,
            gravity=self.gravity,
            h0=self.variable1["h0"],
            v0=self.variable1["v0"],
            angle=self.variable1["angle"],
            timestep=self.variable2["timestep"],
            fps=self.variable3["fps"],
            window_size=self.variable3["size"],
            verbose=self.verbose,
        )
        self.variable4 = trajectory

    def calculate_analytical_trajectory(self):
        """
        Compute the theoretical trajectory using analytical equations.

        Uses
        ----
            param1
            variable1
            variable4

        Modifies
        --------
            variable5

        Generates
        ---------
            out1/results.xlsx
        """

        # Create output directory
        output_dir:Path = Path(self.output_paths["comp_folder"])
        output_dir.mkdir(
            exist_ok=True,
            parents=True,
        )

        # Compute analytical solution
        df_results = units.compute_analytical_trajectory(
            df=self.variable4,
            v0=self.variable1["v0"],
            h0=self.variable1["h0"],
            angle=self.variable1["angle"],
            gravity=self.gravity,
        )
        self.variable5 = df_results

        # Save results to Excel
        df_results.to_excel(
            excel_writer=os.path.join(self.output_paths["comp_folder"], "results.xlsx"),
            engine="xlsxwriter",
            index=True,
        )
    
    def compare_model_vs_analytical_trajectories(self):
        """
        Plot and save the comparison between simulated (model) and theoretical trajectories.

        Uses
        ----
            variable5

        Generates
        ---------
            out1/model_vs_theory.png
        """

        units.plot_comparison(
            df=self.variable5,
            filename=os.path.join(self.output_paths["comp_folder"], "model_vs_theory.png"),
            verbose=self.verbose,
        )


if __name__ == "__main__":
    
    # Define working directory
    working_dir = Path(os.environ["WORKING_DIR"])/"ONE_APP/Study1/2_AnotherProc/Test1"

    # Go to working directory
    os.chdir(working_dir)

    # Create dictionary containing input data
    dict_inputs = {
        "param1": -9.81,
        "param2": 1.0,
        "path1": Path(os.environ["WORKING_DIR"])/"ONE_APP/study1/0_inputs/input2.json",
        "path2": Path(os.environ["WORKING_DIR"])/"ONE_APP/study1/0_inputs/input3",
        "path3": Path(os.environ["WORKING_DIR"])/"ONE_APP/study1/1_OneProc/Test1/output1.csv",
    }
    
    # Create process
    process = AnotherProc(
        dict_inputs=dict_inputs,
        set_inputs=True,
    )
    process.output_paths["out1"] = "output3"

    # Run process
    process()
    process.finalize()